{"meta":{"title":"Fghk的博客","subtitle":"热衷折腾的普通宅男","description":"热衷折腾的普通宅男","author":"Fghk","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2023-01-26T11:26:25.000Z","updated":"2023-01-26T11:26:33.640Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-01-26T11:25:52.000Z","updated":"2023-01-26T11:26:17.834Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"快速入门网页开发","slug":"快速入门网页开发","date":"2023-01-28T13:01:28.000Z","updated":"2023-01-28T14:21:15.482Z","comments":true,"path":"2023/01/28/快速入门网页开发/","link":"","permalink":"http://example.com/2023/01/28/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/","excerpt":"","text":"一个网页由html,css,javascript组成 html负责网页的整体框架部分 css负责网页的样式部分 javascript负责实现网页的逻辑部分 HtmlHtml是一门超文本标记语言，使用一个个标签和属性来构建出整个网页一个标签的构成如下1&lt;开始标签&gt;内容&lt;/结束标签&gt; 但是，也有部分特例，就是单标签1&lt;标签 /&gt; 一个网页的基本框架如下12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 其中&lt;!DOCTYPE html&gt;声明html版本为html5 &lt;html&gt;标签包裹整个网页 &lt;head&gt;通常在其内部声明一些内容和引入文件 &lt;meta charset=&quot;UTF-8&quot;&gt;声明网页是一个中文网页 &lt;title&gt;标签声明了网页的标题，就是显示在浏览器顶部标签栏的网页标题 &lt;body&gt;标签内通常写网页的内容 以上就是网页的基础内容","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"html","slug":"html","permalink":"http://example.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"},{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"Vue速通","slug":"Vue速通","date":"2023-01-28T10:23:27.000Z","updated":"2023-01-28T13:00:57.307Z","comments":true,"path":"2023/01/28/Vue速通/","link":"","permalink":"http://example.com/2023/01/28/Vue%E9%80%9F%E9%80%9A/","excerpt":"","text":"初识VueVue是一款用于构建用户界面的JavaScript框架，基于标准Html、Css和JavaScript构建，并提供声明式，组件化的编程模型，帮助我们有效的构建用户界面。下面是一个基本示例123456789import &#123; createApp &#125; from &#x27;vue&#x27;createApp(&#123; data() &#123; return &#123; count: 0 &#125; &#125;&#125;).mount(&#x27;#app&#x27;) 12345&lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;count++&quot;&gt; Count is: &#123;&#123; count &#125;&#125; &lt;/button&gt;&lt;/div&gt; 页面提供了一个按钮，点击按钮会使按钮上数字增加Vue是一个渐进式框架，拥有自己的生态，涵盖了大部分前端开发的需求。不同开发者对Vue的需求各有不同，Vue可以被逐步集成，开发者可以根据使用场景，以不同方式使用Vue： 无需构建步骤，渐进式增强静态的Html 在任何页面中作为Web Components嵌入 单页面应用(SPA) 全栈&#x2F;服务端渲染(SSR) Jamstack&#x2F;静态站点生成(SSG) 开发桌面端，移动端，WebGL，甚至是终端中的界面 单文本组件Vue可以使用.vue文件，将html,css,javascript封装进一个文件内上面的示例可以改为12345678910111213141516171819&lt;script&gt;export default &#123; data() &#123; return &#123; count: 0 &#125; &#125;&#125;&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;count++&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;&lt;style scoped&gt;button &#123; font-weight: bold;&#125;&lt;/style&gt; 创建一个Vue项目对于Vue来说可以使用Vite来构建项目可以使用下面的命令中的任意一个来使用Vite构建一个Vue项目12npm create vite@latestyarn create vite 然后在项目根目录使用下面的命令之一就可以下载项目需要的包12npm installyarn install 然后使用命令启动项目1yarn dev 再之后访问http://localhost:5173/便可以访问到运行的项目创建一个应用每个Vue应用都是通过createApp函数创建一个新的应用实例12345import &#123; createApp &#125; from &#x27;vue&#x27;;const app = createApp(&#123; //根组件选项&#125;) 根组件传入createApp的对象实际是一个组件，每个应用都需要一个根组件，其他组件将作为其子组件。使用单文本组件时，可以从另一个文件引入根组件1234import &#123; createApp &#125; form &#x27;vue&#x27;;import App from &#x27;./App.vue&#x27;;const app = createApp(App); 挂载应用应用实例必须在调用了.mount()方法后才会渲染出来。该方法接受一个容器参数，可以是一个实际的DOM元素或一个css选择器字符串1&lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 1app.mount(&quot;#app&quot;); 根组件的内容会被渲染进容器元素内根组件模板123&lt;div id=&quot;#app&quot;&gt; &lt;button @click=&quot;count++&quot;&gt;&#123;&#123;count&#125;&#125;&lt;/button&gt;&lt;/div&gt; 123456789import &#123; createApp &#125; from &#x27;vue&#x27;;createApp(&#123; data() &#123; return &#123; count: 0 &#125; &#125;&#125;).mount(&#x27;#app&#x27;); 应用配置应用暴露一个.config对象允许我们配置一些应用级选项123app.config.errorHeader = (err) =&gt; &#123; /* 处理错误 */&#125; 多个应用实例应用实例不只限于一个123456789const app1 = createApp(&#123; /* ... */&#125;)app1.mount(&#x27;#container-1&#x27;)const app2 = createApp(&#123; /* ... */&#125;)app2.mount(&#x27;#container-2&#x27;)","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vite","slug":"Vite","permalink":"http://example.com/tags/Vite/"}]},{"title":"数据结构_1","slug":"数据结构-1","date":"2023-01-27T07:02:51.000Z","updated":"2023-01-27T13:21:58.778Z","comments":true,"path":"2023/01/27/数据结构-1/","link":"","permalink":"http://example.com/2023/01/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/","excerpt":"","text":"数组数组是一种线性的数据结构，利用一组连续的空间，存储相同类型的数据 线性数据结构排成像线一样的数据结构，意味着它只有前后两个方向 连续空间使得数据可以随机访问，使得访问数组中某个元素非常方便，但在修改（删除，插入）元素时，操作会变得麻烦 首先写出数据结构的基础类12345678910111213141516export class FghkArray&lt;T&gt; &#123; // 当前使用了的容量 private size: number; // 存储的数据 private data: T[]; // FghkArray构造函数，传入参数为长度或传入数组 constructor(params?: number | T[]) &#123; if (Array.isArray(params)) &#123; this.data = params; this.size = params.length; &#125; else &#123; this.data = new Array(params ?? 10); this.size = 0; &#125; &#125;&#125; 完成几个基础方法的编写123456789101112// 获取数组中的元素个数getSize(): number &#123; return this.size;&#125;// 获取数组容量getCapacity(): number &#123; return this.data.length;&#125;// 判断数组是否为空isEmpty(): boolean &#123; return this.size ? true : false;&#125; 插入元素方法编写1234567891011121314151617// 在index位置插入一个元素eadd(index: number, e: T) &#123; if(index &lt; 0 || index &gt;= this.size)&#123; throw new Error(&quot;添加元素错误，index范围出错&quot;); &#125; // 扩容 if(this.size === this.data.length) &#123; this.resize(2 * this.data.length); &#125; for(let i = this.size - 1; i &gt;= index; i--) &#123; this.data[i+1] = this.data[i]; &#125; this.data[index] = e; this.size++;&#125; 其中需要考量的是对于数组已满时，需要对数组扩容所以我们在类中写一个重新分配大小的函数 123456789// resize重新分配空间大小private resize(newCapacity: number): void &#123; const newData: T[]= new Array(newCapacity); for(let i = 0; i &lt; this.size; i++)&#123; newData[i] = this.data[i]; &#125; this.data = newData;&#125; 然后利用之前写好的add函数，添加一些其他的基础函数1234567891011// 想数组头添加元素，返回长度unshift(e: T): number &#123; this.add(0, e); return this.getSize();&#125;// 向末尾添加一个元素push(e: T): number &#123; this.add(this.size, e); return this.getSize();&#125; 接下来我们写删除数组元素12345678910111213141516171819// 删除index位置的元素，返回删除的元素remove(index: number): T &#123; if(index &lt; 0 || index &gt;= this.size) &#123; throw new Error(&quot;删除错误，索引取值出错&quot;); &#125; const res: T = this.data[index]; for(let i = index + 1; i &lt; this.size; i++) &#123; this.data[i-1] = this.data[i]; &#125; this.size--; // 缩容 if(this.size === this.data.length &gt;&gt; 2 &amp;&amp; this.data.length &gt;&gt; 1 !== 0) &#123; this.resize(this.data.length &gt;&gt; 1); &#125; return res;&#125; 当前大小只有总容量的四分之一，且总容量的二分之一不为0时缩小数组一半容量 123if(this.size === this.data.length &gt;&gt; 2 &amp;&amp; this.data.length &gt;&gt; 1 !== 0) &#123; this.resize(this.data.length &gt;&gt; 1);&#125; 和之前插入元素一样，基于remove函数添加一些其他函数123456789101112131415// 删除元素eremoveElement(e: T): void &#123; const index = this.indexOf(e); this.remove(index);&#125;// 删除第一个元素，返回元素值shift(): T&#123; return this.remove(0);&#125;// 删除最后一个元素，返回元素值pop(): T&#123; return this.remove(this.size - 1);&#125; 编写一些对数组进行查询的方法1234567891011121314151617181920212223242526272829303132333435// 查找是否有元素econtains(e: T): boolean &#123; for(let i = 0; i &lt; this.size; i++) &#123; if(isEqual(this.data[i], e)) &#123; return true; &#125; &#125; return false;&#125;// 返回给定元素e在数组中的第一个索引，不存在返回-1indexOf(e: T): number &#123; for(let i = 0; i &lt; this.size; i++) &#123; if(isEqual(this.data[i], e)) &#123; return i; &#125; &#125; return -1;&#125;// 获取index位置的元素get(index: number): T &#123; if(index &lt; 0 || index &gt;= this.size) &#123; throw new Error(&quot;获取元素出错，索引取值出错&quot;); &#125; return this.data[index];&#125;getFirst(): T &#123; return this.data[0];&#125;getLast(): T &#123; return this.data[this.size - 1];&#125; 编写一些对数组元素进行更改的方法1234567891011121314151617// 设置索引处元素为eset(index: number, e: T): void &#123; if(index &lt; 0 || index &gt;= this.size) &#123; throw new Error(&quot;设置元素出错，索引取值出错&quot;); &#125; this.data[index] = e;&#125;// 交换swap(i: number, j: number): void &#123; if(i &lt; 0 || i &gt; this.size || j &lt; 0 || j &gt; this.size) &#123; throw new Error(&quot;交换出错，索引取值出错&quot;); &#125; let tmp: T = this.data[i]; this.data[i] = this.data[j]; this.data[j] = tmp;&#125; 编写将数组内元素组合成字符串返回的方法12345678910111213// 格式化输出toString(): string &#123; let res: string = `\\nFghkArray: size=$&#123;this.size&#125;, capacity=$&#123;this.data.length&#125;`; res += &#x27;[&#x27;; for(let i = 0; i &lt; this.size; i++) &#123; res += `$&#123;this.data[i]&#125;`; if(i !== this.size - 1) &#123; res += &#x27;,&#x27;; &#125; &#125; res += &#x27;]&#x27;; return res;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"微积分_1","slug":"微积分-1","date":"2023-01-26T13:37:10.000Z","updated":"2023-01-28T14:54:29.011Z","comments":true,"path":"2023/01/26/微积分-1/","link":"","permalink":"http://example.com/2023/01/26/%E5%BE%AE%E7%A7%AF%E5%88%86-1/","excerpt":"","text":"UNITI_1 微分导数 几何角度 某曲线函数上一点P，坐标为$(x_0,y_0)$$x_0$沿x轴移动距离$\\Delta x$，其对应点为Q定义割线为过点P到点Q的直线随着点Q逐渐趋近于点P，割线将逐渐趋近于点P的切线导数的几何意义为切线的斜率，即两点逼近下割线的斜率导数的定义$$f^′(x_0) &#x3D; \\lim_{\\Delta x \\to 0}{\\frac {\\Delta f}{\\Delta x}} &#x3D; \\lim_{\\Delta x \\to 0}{\\frac {f(x_0+\\Delta x)-f(x_0)}{\\Delta x}}$$$$其中{\\frac {f(x_0+\\Delta x)-f(x_0)}{\\Delta x}}表示差商$$$$f^′&#x3D;{\\frac {df}{dx}}&#x3D;{\\frac {dy}{dx}}&#x3D;{\\frac {d}{dx}}f&#x3D;{\\frac {d}{dx}}y$$ Example1 $函数求导f(x)&#x3D;{\\frac {1}{x}}$$${\\frac {\\Delta y}{\\Delta x}}&#x3D;{\\frac {\\frac {1}{x_0+\\Delta x}+\\frac {1}{x_0}}{\\Delta x}}&#x3D;{\\frac {1}{\\Delta y}}({\\frac {x_0-x_0-\\Delta x}{(x_0+\\Delta x)x_0}})&#x3D;{\\frac {-\\Delta x}{(x_0+\\Delta x)x_0}}$$取极限$x_0 \\to 0$，可得$$\\lim_{\\Delta x \\to 0}{\\frac {\\Delta f}{\\Delta x}} &#x3D; {\\frac {-1}{x_0^2}}$$ Example2 $函数求导f(x)&#x3D;x^n$$${\\frac {\\Delta f}{\\Delta x}} &#x3D; {\\frac {(x_0+\\Delta x)^n-x_0^n}{\\Delta x}}&#x3D;{\\frac {1}{\\Delta x}}(x_0^2+nx_0^{n-1}\\Delta x+O(\\Delta x)^2-x_0^n)&#x3D;(nx_n^{n-1}+O(\\Delta x))$$其中$O(\\Delta x)^2$取极限$x_0 \\to 0$，可得$$\\lim_{\\Delta x \\to 0}{\\frac {\\Delta f}{\\Delta x}}&#x3D;nx_0^{n-1}$$ 物理角度 导数在物理表现为变化率: $$\\lim_{\\Delta x \\to 0}{\\frac {\\Delta y}{\\Delta x}}&#x3D;{\\frac {dy}{dx}}$$ ${\\frac {\\Delta y}{\\Delta x}}$ 表示的是一种平均值 ${\\frac {dy}{dx}}$ 表示的是一种瞬时值 随着$\\Delta x \\to 0$，平均值将趋近于瞬时值 示例 当q表示电荷时， ${\\frac {dq}{dt}}$ 表示瞬时电流当s表示路程时， ${\\frac {ds}{dt}}$ 表示瞬时速度瞬时变化率还可用于测量灵敏度 极限极限可以描述变化的趋势，但不是所有趋势都可以用极限描述 极限的两种情况 简单模式：直接带入值$$\\lim_{x \\to 1}{\\frac {1}{x}}&#x3D;1$$ 复杂模式：需要进行对消运算才能带入$$\\lim_{x \\to 0}{\\frac {x^2+x}{x}}&#x3D;\\lim_{x \\to 0}{x+1}&#x3D;1$$ 极限逼近的方向 左极限：$\\lim_{x \\to x_0^-}{f(x)}$ 其中 $x&lt;x_0^-$ 右极限：$\\lim_{x \\to x_0^+}{f(x)}$ 其中 $x&gt;x_0^+$ 连续函数$f(x)$在点$x_0$处连续的定义$$\\lim_{x \\to x_0}{f(x)}&#x3D;f(x_0)$$ 满足定义的三个条件 左右极限存在且相等 $\\lim_{x\\to x^-}{f(x)}&#x3D;\\lim_{x\\to x^+}{f(x)}$ 函数 $f(x)$ 在 $x_0$ 处有定义 函数值 $f(x_0)$ 与极限值 $\\lim_{x\\to x_0}{f(x)}$ 相等 四种间断 跳跃间断：左右极限存在且不相等 可去间断：左右极限存在且相等，但不等于函数值 举例： $\\frac {sin(x)}{x}$ $\\lim_{x\\to 0}{\\frac {sin(x)}{x}} &#x3D; 1$ 函数在 $x&#x3D;0$ 处无定义 无穷间断 举例： $\\frac {1}{x}$ $\\lim_{x\\to o^+}{\\frac {1}{x}}&#x3D;\\infty$ $\\lim_{x\\to 0^-}{\\frac {1}{x}}&#x3D;-\\infty$ 奇函数 $\\frac {1}{x}$ 求导后变成了偶函数 另类间断 无穷间断：$sin(\\frac {1}{x})$ 随着 $x\\to 0$ 函数 $\\lim_{x\\to 0}{f(x)}$ 将剧烈震荡 函数在 $x&#x3D;0$ 处不存在左极限与右极限 可导必连续 证明$$\\lim_{x\\to x_0}{f(x)}-f(x_0) &#x3D; \\lim_{x\\to 0}{\\frac {f(x)-f(x_0)}{x-x_0}}(x-x_0)$$$$&#x3D;\\lim_{x\\to x_0}{f^′(x)(x-x_0)}$$$$&#x3D;f^′(x) \\times 0$$$$&#x3D;0$$满足函数 $f(x)$ 在 $x_0$ 处连续的定义$$\\lim_{x\\to x_0}{f(x)}&#x3D;f(x_0)$$","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"微积分","slug":"微积分","permalink":"http://example.com/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"}]},{"title":"算法基础","slug":"基础算法","date":"2023-01-26T11:11:17.000Z","updated":"2023-01-26T13:33:59.394Z","comments":true,"path":"2023/01/26/基础算法/","link":"","permalink":"http://example.com/2023/01/26/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/","excerpt":"","text":"基础算法快速排序——分治 确定分治点：q[l]，q[(l+r)&#x2F;2]，q[r]，随机 调整区间：使第一个区间所有数小于等于 x，第二个区间所有数大于 x（_难点_） 暴力做法： 开数组 a[]，b[] 对于 q[l~r]，小于 x 的数存入 a，大于等于 x 的数存入 b 然后递归排序，将 a，b 内的数依次放入 q 中 双指针做法： 定义指针 i，j 在 q[l~r]内，i 向右走，j 向左走，如果 i 指向的数大于等于 x，i 停下，如果 j 指向的数小于等于 x，j 停下，当 i，j 都停下时，交换 i，j 指向的数，继续执行，直到 i，j 相遇 当 i，j 相遇后对 q[l，j]，q[i，r]进行递归 递归：递归处理左右两端 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;int N = 1e6 + 10;int n;int q[N];void quick_sort(int q[],int l,int r)&#123; if(l==r)return; int x=q[l],i=l-1,j=r+1; while(l&lt;r)&#123; do i++ while(q[i]&lt;x); do j-- while(q[j]&gt;x); if(i&lt;j)swap(q[i],q[j]); &#125; //当x=q[l]时，如下写 quick_sort(q,l,j); quick_sort(q,j+1,r); //当x=q[r]时 quick_sort(q,l,i-1); quick_sort(q,i,r); //否则会出现边界问题 //例如q[]=&#123;1,2&#125; //x=q[l]=1 //quick_sort(q,l,i-1)=quick_sort(q,0,-1) //x=q[r]=2 //quick_sort(q,j+1,r)=quick_sort(q,2,1)&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;q[i]); quick_sort(q,0,n-1); for(int i=0;i&lt;n;i++)printf(&quot;%d&quot;,q[i]); return 0;&#125; 归并排序——分治 确定分治点 mid&#x3D;(l+r)&#x2F;2 递归排序 left，right 归并——合而为一（_难点_） 对于排序好的序列 left，right，取两个指针分别指向头部，并用 res 存储归并后的序列 对两个指针所指向的数进行对比，将小的放入 res 中，并使指针+1，直到某一个数组为空，再将另一个数组接至 res 后面 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;const int N = 1000010;int q=[N],tmp[N];int n;void merge_sort(int q[],int l,int r)&#123; if(l==r)return; int mid=(l+r) &gt;&gt; 1; merge_sort(q,l,mid); merge_sort(q,mid+1,r); int k=0,i=l,j=mid+1; while(i&lt;=mid &amp;&amp; j&lt;=r) if(q[i]&lt;=q[j])tmp[k++]=q[i++]; else tmp[k++]=q[j++]; while(i&lt;=mid)tmp[k++]=q[i++]; while(j&lt;=r)tmp[k++]=q[j++]; for(i=l,j=0;i&lt;=r;i++,j++)q[i]=tmp[j];&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;q[i]); merge_sort(q,0,n-1); for(int i=0;i&lt;n;i++)printf(&quot;%d&quot;,q[i]); return 0;&#125; 二分 二分的本质不是单调性，有单调性一定可以二分，能二分不一定有单调性 整数二分 在区间 q[l~r]中定义了某种性质，性质使区间一分为二,红色区间不满足，绿色区间满足 二分出红色边界 1234567void bsearch(int l,int r)&#123; while(l&lt;r)&#123; int mid = (l+r+1) &gt;&gt; 1; if(check(mid)) l=mid; else r=mid-1; &#125;&#125; 为什么 mid&#x3D;(l+r+1) &gt;&gt; 1;? 当 l&#x3D;r-1 时，(l+r)&gt;&gt;1&#x3D;l，如果 check&#x3D;true 的话 l&#x3D;mid&#x3D;l，便会进入死循环 二分出绿色边界 1234567void bsearch(int l,int r)&#123; while(l&lt;r)&#123; int mid = (l+r) &gt;&gt; 1; if(check(mid)) r = mid; else l = mid + 1; &#125;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]}],"categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"html","slug":"html","permalink":"http://example.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"},{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"Vite","slug":"Vite","permalink":"http://example.com/tags/Vite/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"},{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"微积分","slug":"微积分","permalink":"http://example.com/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]}