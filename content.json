{"meta":{"title":"Fghk的博客","subtitle":"热衷折腾的普通宅男","description":"热衷折腾的普通宅男","author":"Fghk","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2023-01-26T11:26:25.000Z","updated":"2023-01-26T11:26:33.640Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-01-26T11:25:52.000Z","updated":"2023-01-26T11:26:17.834Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数据结构_1","slug":"数据结构-1","date":"2023-01-27T07:02:51.000Z","updated":"2023-01-27T13:09:05.891Z","comments":true,"path":"2023/01/27/数据结构-1/","link":"","permalink":"http://example.com/2023/01/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/","excerpt":"","text":"数据结构数组首先写出数据结构的基础类 12345678910111213141516export class FghkArray&lt;T&gt; &#123; // 当前使用了的容量 private size: number; // 存储的数据 private data: T[]; // FghkArray构造函数，传入参数为长度或传入数组 constructor(params?: number | T[]) &#123; if (Array.isArray(params)) &#123; this.data = params; this.size = params.length; &#125; else &#123; this.data = new Array(params ?? 10); this.size = 0; &#125; &#125;&#125; 完成几个基础方法的编写 123456789101112// 获取数组中的元素个数getSize(): number &#123; return this.size;&#125;// 获取数组容量getCapacity(): number &#123; return this.data.length;&#125;// 判断数组是否为空isEmpty(): boolean &#123; return this.size ? true : false;&#125; 插入元素方法编写 1234567891011121314151617// 在index位置插入一个元素eadd(index: number, e: T) &#123; if(index &lt; 0 || index &gt;= this.size)&#123; throw new Error(&quot;添加元素错误，index范围出错&quot;); &#125; // 扩容 if(this.size === this.data.length) &#123; this.resize(2 * this.data.length); &#125; for(let i = this.size - 1; i &gt;= index; i--) &#123; this.data[i+1] = this.data[i]; &#125; this.data[index] = e; this.size++;&#125; 其中需要考量的是对于数组已满时，需要对数组扩容所以我们在类中写一个重新分配大小的函数 123456789// resize重新分配空间大小private resize(newCapacity: number): void &#123; const newData: T[]= new Array(newCapacity); for(let i = 0; i &lt; this.size; i++)&#123; newData[i] = this.data[i]; &#125; this.data = newData;&#125; 然后利用之前写好的add函数，添加一些其他的基础函数 1234567891011// 想数组头添加元素，返回长度unshift(e: T): number &#123; this.add(0, e); return this.getSize();&#125;// 向末尾添加一个元素push(e: T): number &#123; this.add(this.size, e); return this.getSize();&#125; 接下来我们写删除数组元素 12345678910111213141516171819// 删除index位置的元素，返回删除的元素remove(index: number): T &#123; if(index &lt; 0 || index &gt;= this.size) &#123; throw new Error(&quot;删除错误，索引取值出错&quot;); &#125; const res: T = this.data[index]; for(let i = index + 1; i &lt; this.size; i++) &#123; this.data[i-1] = this.data[i]; &#125; this.size--; // 缩容 if(this.size === this.data.length &gt;&gt; 2 &amp;&amp; this.data.length &gt;&gt; 1 !== 0) &#123; this.resize(this.data.length &gt;&gt; 1); &#125; return res;&#125; 当前大小只有总容量的四分之一，且总容量的二分之一不为0时缩小数组一半容量 123if(this.size === this.data.length &gt;&gt; 2 &amp;&amp; this.data.length &gt;&gt; 1 !== 0) &#123; this.resize(this.data.length &gt;&gt; 1);&#125; 和之前插入元素一样，基于remove函数添加一些其他函数 123456789101112131415// 删除元素eremoveElement(e: T): void &#123; const index = this.indexOf(e); this.remove(index);&#125;// 删除第一个元素，返回元素值shift(): T&#123; return this.remove(0);&#125;// 删除最后一个元素，返回元素值pop(): T&#123; return this.remove(this.size - 1);&#125; 对数组进行查询 1234567891011121314151617181920212223242526272829303132333435// 查找是否有元素econtains(e: T): boolean &#123; for(let i = 0; i &lt; this.size; i++) &#123; if(isEqual(this.data[i], e)) &#123; return true; &#125; &#125; return false;&#125;// 返回给定元素e在数组中的第一个索引，不存在返回-1indexOf(e: T): number &#123; for(let i = 0; i &lt; this.size; i++) &#123; if(isEqual(this.data[i], e)) &#123; return i; &#125; &#125; return -1;&#125;// 获取index位置的元素get(index: number): T &#123; if(index &lt; 0 || index &gt;= this.size) &#123; throw new Error(&quot;获取元素出错，索引取值出错&quot;); &#125; return this.data[index];&#125;getFirst(): T &#123; return this.data[0];&#125;getLast(): T &#123; return this.data[this.size - 1];&#125; 对数组元素进行更改 1234567891011121314151617// 设置索引处元素为eset(index: number, e: T): void &#123; if(index &lt; 0 || index &gt;= this.size) &#123; throw new Error(&quot;设置元素出错，索引取值出错&quot;); &#125; this.data[index] = e;&#125;// 交换swap(i: number, j: number): void &#123; if(i &lt; 0 || i &gt; this.size || j &lt; 0 || j &gt; this.size) &#123; throw new Error(&quot;交换出错，索引取值出错&quot;); &#125; let tmp: T = this.data[i]; this.data[i] = this.data[j]; this.data[j] = tmp;&#125; 将数组内元素组合成字符串返回 12345678910111213// 格式化输出toString(): string &#123; let res: string = `\\nFghkArray: size=$&#123;this.size&#125;, capacity=$&#123;this.data.length&#125;`; res += &#x27;[&#x27;; for(let i = 0; i &lt; this.size; i++) &#123; res += `$&#123;this.data[i]&#125;`; if(i !== this.size - 1) &#123; res += &#x27;,&#x27;; &#125; &#125; res += &#x27;]&#x27;; return res;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"微积分_1","slug":"微积分-1","date":"2023-01-26T13:37:10.000Z","updated":"2023-01-27T11:58:31.099Z","comments":true,"path":"2023/01/26/微积分-1/","link":"","permalink":"http://example.com/2023/01/26/%E5%BE%AE%E7%A7%AF%E5%88%86-1/","excerpt":"","text":"UNITI_1 微分导数 几何角度某曲线函数上一点P，坐标为$(x_0,y_0)$$x_0$沿x轴移动距离$\\Delta x$，其对应点为Q定义割线为过点P到点Q的直线随着点Q逐渐趋近于点P，割线将逐渐趋近于点P的切线导数的几何意义为切线的斜率，即两点逼近下割线的斜率导数的定义 f^′(x_0) = \\lim_{\\Delta x \\to 0}{\\frac {\\Delta f}{\\Delta x}} = \\lim_{\\Delta x \\to 0}{\\frac {f(x_0+\\Delta x)-f(x_0)}{\\Delta x}}其中{\\frac {f(x_0+\\Delta x)-f(x_0)}{\\Delta x}}表示差商 f^′={\\frac {df}{dx}}={\\frac {dy}{dx}}={\\frac {d}{dx}}f={\\frac {d}{dx}}y Example1 $函数求导f(x)={\\frac {1}{x}}$ {\\frac {\\Delta y}{\\Delta x}}={\\frac {\\frac {1}{x_0+\\Delta x}+\\frac {1}{x_0}}{\\Delta x}}={\\frac {1}{\\Delta y}}({\\frac {x_0-x_0-\\Delta x}{(x_0+\\Delta x)x_0}})={\\frac {-\\Delta x}{(x_0+\\Delta x)x_0}}取极限$x_0 \\to 0$，可得 \\lim_{\\Delta x \\to 0}{\\frac {\\Delta f}{\\Delta x}} = {\\frac {-1}{x_0^2}} Example2 $函数求导f(x)=x^n$ {\\frac {\\Delta f}{\\Delta x}} = {\\frac {(x_0+\\Delta x)^n-x_0^n}{\\Delta x}}={\\frac {1}{\\Delta x}}(x_0^2+nx_0^{n-1}\\Delta x+O(\\Delta x)^2-x_0^n)=(nx_n^{n-1}+O(\\Delta x))其中$O(\\Delta x)^2$取极限$x_0 \\to 0$，可得 \\lim_{\\Delta x \\to 0}{\\frac {\\Delta f}{\\Delta x}}=nx_0^{n-1} 物理角度 导数的重要性 如何求导任意函数","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"微积分","slug":"微积分","permalink":"http://example.com/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"}]},{"title":"算法基础","slug":"基础算法","date":"2023-01-26T11:11:17.000Z","updated":"2023-01-26T13:33:59.394Z","comments":true,"path":"2023/01/26/基础算法/","link":"","permalink":"http://example.com/2023/01/26/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/","excerpt":"","text":"基础算法快速排序——分治 确定分治点：q[l]，q[(l+r)&#x2F;2]，q[r]，随机 调整区间：使第一个区间所有数小于等于 x，第二个区间所有数大于 x（_难点_） 暴力做法： 开数组 a[]，b[] 对于 q[l~r]，小于 x 的数存入 a，大于等于 x 的数存入 b 然后递归排序，将 a，b 内的数依次放入 q 中 双指针做法： 定义指针 i，j 在 q[l~r]内，i 向右走，j 向左走，如果 i 指向的数大于等于 x，i 停下，如果 j 指向的数小于等于 x，j 停下，当 i，j 都停下时，交换 i，j 指向的数，继续执行，直到 i，j 相遇 当 i，j 相遇后对 q[l，j]，q[i，r]进行递归 递归：递归处理左右两端 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;int N = 1e6 + 10;int n;int q[N];void quick_sort(int q[],int l,int r)&#123; if(l==r)return; int x=q[l],i=l-1,j=r+1; while(l&lt;r)&#123; do i++ while(q[i]&lt;x); do j-- while(q[j]&gt;x); if(i&lt;j)swap(q[i],q[j]); &#125; //当x=q[l]时，如下写 quick_sort(q,l,j); quick_sort(q,j+1,r); //当x=q[r]时 quick_sort(q,l,i-1); quick_sort(q,i,r); //否则会出现边界问题 //例如q[]=&#123;1,2&#125; //x=q[l]=1 //quick_sort(q,l,i-1)=quick_sort(q,0,-1) //x=q[r]=2 //quick_sort(q,j+1,r)=quick_sort(q,2,1)&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;q[i]); quick_sort(q,0,n-1); for(int i=0;i&lt;n;i++)printf(&quot;%d&quot;,q[i]); return 0;&#125; 归并排序——分治 确定分治点 mid&#x3D;(l+r)&#x2F;2 递归排序 left，right 归并——合而为一（_难点_） 对于排序好的序列 left，right，取两个指针分别指向头部，并用 res 存储归并后的序列 对两个指针所指向的数进行对比，将小的放入 res 中，并使指针+1，直到某一个数组为空，再将另一个数组接至 res 后面 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;const int N = 1000010;int q=[N],tmp[N];int n;void merge_sort(int q[],int l,int r)&#123; if(l==r)return; int mid=(l+r) &gt;&gt; 1; merge_sort(q,l,mid); merge_sort(q,mid+1,r); int k=0,i=l,j=mid+1; while(i&lt;=mid &amp;&amp; j&lt;=r) if(q[i]&lt;=q[j])tmp[k++]=q[i++]; else tmp[k++]=q[j++]; while(i&lt;=mid)tmp[k++]=q[i++]; while(j&lt;=r)tmp[k++]=q[j++]; for(i=l,j=0;i&lt;=r;i++,j++)q[i]=tmp[j];&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;q[i]); merge_sort(q,0,n-1); for(int i=0;i&lt;n;i++)printf(&quot;%d&quot;,q[i]); return 0;&#125; 二分 二分的本质不是单调性，有单调性一定可以二分，能二分不一定有单调性 整数二分 在区间 q[l~r]中定义了某种性质，性质使区间一分为二,红色区间不满足，绿色区间满足 二分出红色边界 1234567void bsearch(int l,int r)&#123; while(l&lt;r)&#123; int mid = (l+r+1) &gt;&gt; 1; if(check(mid)) l=mid; else r=mid-1; &#125;&#125; 为什么 mid&#x3D;(l+r+1) &gt;&gt; 1;? 当 l&#x3D;r-1 时，(l+r)&gt;&gt;1&#x3D;l，如果 check&#x3D;true 的话 l&#x3D;mid&#x3D;l，便会进入死循环 二分出绿色边界 1234567void bsearch(int l,int r)&#123; while(l&lt;r)&#123; int mid = (l+r) &gt;&gt; 1; if(check(mid)) r = mid; else l = mid + 1; &#125;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]}],"categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"微积分","slug":"微积分","permalink":"http://example.com/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]}