{"meta":{"title":"Fghk的博客","subtitle":"热衷折腾的普通宅男","description":"热衷折腾的普通宅男","author":"Fghk","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2023-01-26T11:26:25.000Z","updated":"2023-01-26T11:26:33.640Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-01-26T11:25:52.000Z","updated":"2023-01-26T11:26:17.834Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"微积分_1","slug":"微积分-1","date":"2023-01-26T13:37:10.000Z","updated":"2023-01-27T04:02:32.318Z","comments":true,"path":"2023/01/26/微积分-1/","link":"","permalink":"http://example.com/2023/01/26/%E5%BE%AE%E7%A7%AF%E5%88%86-1/","excerpt":"","text":"UNITI_1 微分导数 几何角度某曲线函数上一点P，坐标为$(x_0,y_0)$$x_0$沿x轴移动距离$\\Delta x$，其对应点为Q定义割线为过点P到点Q的直线随着点Q逐渐趋近于点P，割线将逐渐趋近于点P的切线导数的几何意义为切线的斜率，即两点逼近下割线的斜率导数的定义 f^`(x) = \\lim_{\\Delta x \\to 0}{\\frac {\\Delta f}{\\Delta x}} = \\lim_{\\Delta x \\to 0}{\\frac {f(x_0+\\Delta x)-f(x_0)}{\\Delta x}} 物理角度 导数的重要性 如何求导任意函数","categories":[],"tags":[]},{"title":"算法基础","slug":"基础算法","date":"2023-01-26T11:11:17.000Z","updated":"2023-01-26T13:33:59.394Z","comments":true,"path":"2023/01/26/基础算法/","link":"","permalink":"http://example.com/2023/01/26/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/","excerpt":"","text":"基础算法快速排序——分治 确定分治点：q[l]，q[(l+r)&#x2F;2]，q[r]，随机 调整区间：使第一个区间所有数小于等于 x，第二个区间所有数大于 x（_难点_） 暴力做法： 开数组 a[]，b[] 对于 q[l~r]，小于 x 的数存入 a，大于等于 x 的数存入 b 然后递归排序，将 a，b 内的数依次放入 q 中 双指针做法： 定义指针 i，j 在 q[l~r]内，i 向右走，j 向左走，如果 i 指向的数大于等于 x，i 停下，如果 j 指向的数小于等于 x，j 停下，当 i，j 都停下时，交换 i，j 指向的数，继续执行，直到 i，j 相遇 当 i，j 相遇后对 q[l，j]，q[i，r]进行递归 递归：递归处理左右两端 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;int N = 1e6 + 10;int n;int q[N];void quick_sort(int q[],int l,int r)&#123; if(l==r)return; int x=q[l],i=l-1,j=r+1; while(l&lt;r)&#123; do i++ while(q[i]&lt;x); do j-- while(q[j]&gt;x); if(i&lt;j)swap(q[i],q[j]); &#125; //当x=q[l]时，如下写 quick_sort(q,l,j); quick_sort(q,j+1,r); //当x=q[r]时 quick_sort(q,l,i-1); quick_sort(q,i,r); //否则会出现边界问题 //例如q[]=&#123;1,2&#125; //x=q[l]=1 //quick_sort(q,l,i-1)=quick_sort(q,0,-1) //x=q[r]=2 //quick_sort(q,j+1,r)=quick_sort(q,2,1)&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;q[i]); quick_sort(q,0,n-1); for(int i=0;i&lt;n;i++)printf(&quot;%d&quot;,q[i]); return 0;&#125; 归并排序——分治 确定分治点 mid&#x3D;(l+r)&#x2F;2 递归排序 left，right 归并——合而为一（_难点_） 对于排序好的序列 left，right，取两个指针分别指向头部，并用 res 存储归并后的序列 对两个指针所指向的数进行对比，将小的放入 res 中，并使指针+1，直到某一个数组为空，再将另一个数组接至 res 后面 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;const int N = 1000010;int q=[N],tmp[N];int n;void merge_sort(int q[],int l,int r)&#123; if(l==r)return; int mid=(l+r) &gt;&gt; 1; merge_sort(q,l,mid); merge_sort(q,mid+1,r); int k=0,i=l,j=mid+1; while(i&lt;=mid &amp;&amp; j&lt;=r) if(q[i]&lt;=q[j])tmp[k++]=q[i++]; else tmp[k++]=q[j++]; while(i&lt;=mid)tmp[k++]=q[i++]; while(j&lt;=r)tmp[k++]=q[j++]; for(i=l,j=0;i&lt;=r;i++,j++)q[i]=tmp[j];&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;q[i]); merge_sort(q,0,n-1); for(int i=0;i&lt;n;i++)printf(&quot;%d&quot;,q[i]); return 0;&#125; 二分 二分的本质不是单调性，有单调性一定可以二分，能二分不一定有单调性 整数二分 在区间 q[l~r]中定义了某种性质，性质使区间一分为二,红色区间不满足，绿色区间满足 二分出红色边界 1234567void bsearch(int l,int r)&#123; while(l&lt;r)&#123; int mid = (l+r+1) &gt;&gt; 1; if(check(mid)) l=mid; else r=mid-1; &#125;&#125; 为什么 mid&#x3D;(l+r+1) &gt;&gt; 1;? 当 l&#x3D;r-1 时，(l+r)&gt;&gt;1&#x3D;l，如果 check&#x3D;true 的话 l&#x3D;mid&#x3D;l，便会进入死循环 二分出绿色边界 1234567void bsearch(int l,int r)&#123; while(l&lt;r)&#123; int mid = (l+r) &gt;&gt; 1; if(check(mid)) r = mid; else l = mid + 1; &#125;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]}],"categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]}